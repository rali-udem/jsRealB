<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <title>jsRealB - Documentation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="../dist/jsRealB.js"></script>
    <script src="https://code.jquery.com/jquery-latest.min.js"></script>
    <script src="user.js"></script>
    <script src="user-infos.js"></script>
</head>
<body>
<!-- top menus -->
    <span class="dropdown" id="quicklinks">
      <span lang="fr">Aller à ↓</span><span lang="en">Goto ↓</span>
      <span class="dropdown-content"></span>
    </span>
    <span id="langSelect">[<span lang="en">FR</span><span lang="fr">EN</span>]</span>
<!-- start of page  -->
    <h1><span class="jsr">jsRealB (Version <span class="version-no"></span>)</span> - Documentation</h1>
    <p lang="fr"><span class="jsr">jsRealB</span> est un réalisateur de texte pour l'anglais et le français écrit en JavaScript. Il peut être utilisé soit à l'intérieur d'une page web comme celle-ci dont tous les exemples sont réalisés dynamiquement, ou comme module <code>Node.js</code>.</p>
    <p lang="en"><span class="jsr">jsRealB</span> is a text realizer for French and English written in JavaScript. It can be used either within a web page such as this one whose examples are dynamically realized or as a <code>Node.js</code> module.</p>
    <p lang="fr"><i>Si vous travaillez en Python, vous serez peut-être plus intéressé par <a href="https://github.com/lapalme/pyrealb">pyrealb</a> qui utilise la même notation pour la description des composants des phrases.</i></p>
    <p lang="en"><i>If you are working in Python, you might be more interested by <a href="https://github.com/lapalme/pyrealb">pyrealb</a> which uses the same notation for describing the sentence components.</i></p>

<!-- *** Constituants *** -->
    <h2 lang="fr" id="constituants">Constituants</h2><h2 lang="en" id="constituents">Constituents</h2>
    <div id="terminalsSect"></div>
    <div id="syntagmesSect"></div>
    <div lang="fr">
        <p>Les accords <em>simples</em> sont effectués automatiquement entre les constituants d'un syntagme. Un constituant est considéré comme la <i>tête</i> avec lequel les autres sont accordés. La <i>tête</i> est déterminée de la façon suivante:</p>
        <ul>
            <li><code>NP</code>: le premier <code>N</code> ou <code>NP</code> en tenant compte de la modification possible par un <code>NO</code>, cet accord est propagé à une subordonnée interne au <code>NP</code>;</li>
            <li><code>AP</code>: le premier <code>A</code>;</li>
            <li><code>VP</code>: le premier <code>V</code>;le verbe est accordé avec le sujet (le premier <code>NP</code> ou <code>Pro</code> de la phrase englobante);</li>
            <li><code>S</code>, <code>SP</code>: accord avec le <em>sujet</em>, soit le premier <code>NP</code>, <code>N</code>, 
                <code>Pro</code> ou <code>CP</code>. Si le <code>Pro</code> est un pronom relatif, le <em>sujet</em> de la subordonnée est utilisé. Des tests spécifiques permettent d'accorder le verbe <code>être/be</code> ainsi que pour tenir compte des sujets coordonnés.</li>
        </ul>
        <p>Des options (section suivante) appliquées à une instance de <code>Terminal</code> (e.g. <code>N</code>, <code>V</code>, ...) spécifiant le genre et le nombre l'emportent sur ces accords automatiques.</p>
		<p>Lors d'un appel à un constructeur de syntagme (e.g. <code>S, VP, NP</code>, ...), les paramètres ayant valeur <code>null</code> ou <code>undefined</code> sont ignorés, 
ce qui peut simplifier les appels lors de paramètres optionnels.</p>
    </div>

    <div lang="en">
        <p><em>Simple</em> agreements are dealt automatically with between constituents of a phrase. A constituent is taken as the <i>head</i> with which others agree. The <i>head</i> is found as follows:</p>
        <ul>
            <li><code>NP</code>: the first <code>N</code> or <code>NP</code> taking into account an eventual <code>NO</code>, this agreement is propagated to an internal subordinate phrase;</li>
            <li><code>AP</code>: the first <code>A</code>;</li>
            <li><code>VP</code>: the first <code>V</code>; the verb agrees with its subject (the first <code>NP</code> or <code>Pro</code> in the enclosing sentence);</li>
            <li><code>S</code>, <code>SP</code>: agrees with the <em>subject</em>, taken as the first <code>NP</code>, <code>N</code>, 
                <code>Pro</code> or <code>CP</code>. If the <code>Pro</code> is a relative pronoun, the <em>subject</em> of the subordinate is taken. Specific tests take into account the verbs <code>être/be</code> and the coordinate subjects.</li>
        </ul>
        <p>Options (next section) applied to an instance of <code>Terminal</code> (e.g. <code>N</code>, <code>V</code>, ...) override these automatic agreements.</p>
		<p>When calling a phrase constructor (e.g. <code>S, VP, NP</code>, ...), parameters having value <code>null</code> or <code>undefined</code> are ignored. 
		This can be convenient for dealing with optional parameters.</p>
    </div>

<!-- *** Dépendants *** -->
    <div id="dependentsSect"></div>
	<div lang="fr">
		<p>Le premier paramètre d'une dépendance est un terminal, il doit toujours être spécifié à la création de la dépendance. Les autres paramètres sont optionnels, mais ils doivent être d'autres dépendances.</p>
		<p><code>coord</code> regroupe des <strong>dépendances de même type</strong> coordonnées par la conjonction donnée comme terminal. 
            Les dépendents seront séparés par une virgule sauf les deux derniers qui seront séparés par la conjonction. 
            <code>coord</code> sans dépendent sera ignoré à la réalisation. 
            <code>coord</code> avec un seul dépendent apparaitra sans la conjonction. 
            Si le terminal est une chaîne vide, alors tous les éléments seront séparés par une virgule.
        </p>
		<p>Les accords <em>simples</em> sont effectués automatiquement entre les dépendents:</p>
		<ul>
			<li>Le verbe d'un <code>root</code> s'accorde en personne, en genre et en nombre avec le sujet indiqué par la dépendance <code>subj</code>. Ceci peut être un <code>N</code>, un <code>Pro</code> ou même des dépendents d'un <code>coord</code>. Les attributs et participes passés des verbes copules sont accordés avec leur sujet. Les participes passés des verbes conjugés avec avoir s'accordent avec leur complément d'objet direct s'ils sont placés avant le verbe. Un complément d'objet direct est le terminal d'un <code>comp</code> dont le terminal n'est pas un <code>P</code>.</li>
			<li>Le déterminant d'un <code>det</code> s'accorde en genre et en nombre avec son sujet, i.e. le terminal englobant.</li>
			<li>L'adjectif d'un <code>mod</code> s'accorde en genre et en nombre avec son sujet, i.e. le terminal englobant.</li>
		</ul>
        <p>Des options (section suivante) appliquées à une instance de <code>Terminal</code> (e.g. <code>N</code>, <code>V</code>, ...) spécifiant le genre et le nombre l'emportent sur ces accords automatiques.</p>
        <p>Position des dépendents: <code>det</code> et <code>subj</code> sont réalisées avant le terminal, alors que 
            <code>mod</code>, <code>comp</code> et <code>coord</code> sont réalisées dans l'ordre où
            elles sont spécifiées. Il est possible de modifier cet ordre en utilisant la méthode <code>.mod("pre")</code> pour 
        forcer une dépendance à apparaître avant, ou <code>.mod("post")</code> pour apparaître après.</p>
	</div>
	<div lang="en">
		<p>The first parameter of a dependency is a terminal that must be specified when the dependency is created. The other parameters are optional, but they must be dependents. </p>
		<p><code>coord</code> combine <strong>dependencies of the same type</strong> coordinated by the conjunction given as terminal. 
            Dependencies will comma separated except for the last two that will be separated by the conjunction. 
            A  <code>coord</code> without dependent will not be realized. A <code>coord</code> with a single dependent will be 
            realized without the conjunction. If the terminal is an empty string, then all dependents will be comma separated.</p>
		<p><em>Simple</em> agreements are realized between dependents:</p>
		<ul>
			<li>A verb agrees in person and number with a subject indicated by a <code>subj</code> dependency. 
                The subject can be a <code>N</code>, a <code>Pro</code> or dependents of a <code>coord</code>.</li>
			<li>The determiner of a <code>det</code> agrees in number with its determiner, i.e. its enclosing terminal.</li>
		</ul>
        <p>Options (next section) applied to an instance of <code>Terminal</code> (e.g. <code>N</code>, <code>V</code>, ...) override these automatic agreements.</p>
        <p>Dependent position: <code>det</code> et <code>subj</code> are realized before the terminal, while
            <code>mod</code>, <code>comp</code> et <code>coord</code> are realized after in the order of their specification. 
            This ordering can be changed using <code>.mod("pre")</code> to force a dependent to be realized before, or 
            <code>.mod("post")</code> to be realized after.</p>
	</div>
<!-- *** Déclinaisons et conjugaisons *** -->
    <h2 id="optionsFr" lang="fr">Déclinaisons et conjugaisons</h2><h2 id="optionsEn" lang="en">Declension and conjugation</h2>
    <div id="optionsSect"></div>
    <p lang="en">Perfect and  continuous tenses for verbs can obtained by setting the <a href="#sentType">sentence type</a> to <code>.typ({perf:true})</code> or <code>.typ({prog:true})</code> </p>
    

<!-- *** Pronoms *** -->
    <h2 lang="fr" id="pronoms">Pronoms</h2><h2 lang="en" id="pronouns">Pronouns</h2>
    <p lang="fr">Les pronoms qui sont dans le lexique sont à la 1ère personne du singulier. Pour obtenir les autres, il faut
    spécifier la personne, le nombre et éventuellement le genre. Ce mécanisme s'applique aussi pour les
    pronoms <code>me</code> et <code>moi-même</code> et pour le déterminant <code>mon</code>.</p>
    <p lang="en">Pronouns in the lexicon are at the first person singular. To get the other forms, the gender, the number and
    the person must be specified. The same option mechanism can be used for the pronouns <code>mine</code> and <code>myself</code> and
    for the determiner <code>my</code>.</p>
    <div id="pronomsSect"></div>
    
    <div id="pronomsSect2">
        <h3><span lang="fr">Pronoms en modifiant la forme tonique</span>
            <span lang="en">Pronouns from the tonic form</span>
        </h3>
        <div lang="fr">
            <ul>
                <li>la forme tonique <code>.tn(..)</code> avec comme paramètre 
                    <ul>
                        <li><code>""</code>: pour la forme tonique elle-même</li>
                        <li><code>refl</code> pour obtenir la forme réflexive (terminant en
                     <code>-même</code>)</li>
                    </ul>
                 </li>
                <li>la forme clitique <code>.c(..)</code> avec comme paramètre 
                    <ul>
                        <li><code>nom</code> pour la forme nominative</li>
                        <li><code>acc</code> pour la forme accusative (complément d'objet direct)</li>
                        <li><code>dat</code> pour la forme datif (complément d'objet indirect)</li>
                        <li><code>refl</code> pour la forme réfléchie</li>
                    </ul>
                </li>
            </ul>
            <p>Afin de rester compatible avec la méthode de spécification précédente, les formes clitiques et toniques des pronoms doivent spécifier <code>.pe(1)</code> pour le pronom <code>moi</code>. Il en est de même pour les pronoms possessifs <code>mien</code> et <code>nôtre</code> ainsi que pour les déterminants possessifs <code>mon</code> et <code>notre</code>.</p>
            <p>Le tableau suivant présente la forme obtenue au-dessus de la spécification <span class="jsr">jsRealB</span>.</p>
            <div id="pronomsTon"></div>
            <p>Le tableau suivant présente les pronoms possessifs qui s'accordent en genre et en nombre.</p>
            <div id="pronomsPoss"></div>
            <p>Les déterminants possessifs varient en genre et en nombre à partir de leur 
            forme de base comme le montre le tableau suivant.</p>
            <div id="determinantsPoss"></div>
        </div>
        <div lang="en">
           <ul>
               <li>tonic form <code>.tn(..)</code> with parameter
                   <ul>
                       <li><code>""</code>: for the tonic form itself</li>
                       <li><code>refl</code> to get the reflexive form (ending with <i>self | selves</i>)</li>
                   </ul>
                </li>
               <li>clitic form <code>.c(..)</code> with options:
                   <ul>
                       <li><code>nom</code> for the nominative</li>
                       <li><code>acc</code> for the accusative (direct object)</li>
                       <li><code>dat</code> for the dative (indirect object)</li>
                       <li><code>gen</code> for the genitive (noun complement)</li>
                   </ul>
               </li>
           </ul>
           <p>In order to stay compatible with the previous form of specification, when using tonic or clitic form,
              <code>pe(1)</code> must be specified for the pronoun <code>me</code>.</p>
           <p>The following table shows the realized form above the corresponding 
               <span class="jsr">jsRealB</span> expression.</p>
            <div id="tonicPro"></div>
            <p>Possessive determiners are specified by giving options for the number, the person, 
                the gender (when at the third person) and also if the owner (<code>.ow(..)</code>) 
                is singular or plural. The following table shows the realization above its 
                jsRealB specification.
             </p>
            <div id="possDet"></div>
        </div>
    </div>
    

<!-- *** Mise en forme *** -->
    <h2 lang="fr" id="formattage">Mise en forme</h2><h2 lang="en" id="formatting">Formatting</h2>
    <p lang="fr">Si l'ajout avant et/ou après un constituent correspond à un signe de ponctuation défini dans les règles, l'espacement approprié est ajouté avant et après le signe, sinon la chaîne est ajoutée telle quelle sans espacement.</p>
    <p lang="en">If the content added before and/or a constituent is defined in the language rules, then the appropriate spacing is added before and after the punctuation sign, otherwise the content is added without spacing.</p>
    <div id="formatSect"></div>
    

<!-- *** Modification du syntagme nominal *** -->
    <h2 lang="fr" id="modSN">Position et pronominalization</h2><h2 lang="en" id="npMod">Position and pronominalization</h2>
    <div id="nPmods"></div>
    

<!-- *** Modification du type de phrase *** -->
    <h2 lang="fr" id="changeType">Modification du type de phrase</h2><h2 lang="en" id="typeChange">Sentence type modification</h2>
    <p lang="fr">Les phrases sont construites à la forme active, mais il est possible d'en modifier le type pour obtenir des phrases négatives, progressives, interrogatives ou passives.  Ces modifications sont de la forme <code>S(...).typ({...})</code> Il est possible de combiner plusieurs modifications en spécifiant plusieurs paires clés-valeurs dans l'objet paramètre de <code>.typ</code>. L'utilisation de contractions en anglais telles que <code>I'll</code> pour <code>I will</code> ou <code>can't</code> pour <code>cannot</code> peut aussi être spécifiée de cette manière, mais cet indicateur est ignoré en français.</p>
	<p lang="fr">Ces modifications peuvent aussi être appliquées aux structures en dépendances.</p>
    <p lang="en">Sentences are built at the active voice, but their type can be modified in order to get negative, progressive, interrogative or passive sentences. These modifications are indicated by <code>S(...).typ({...})</code>. Modifications can be combined by specifying multiple key value pairs in the object which is the parameter of <code>.typ</code>. The use of contractions such as <code>I'll</code> for <code>I will</code> or <code>can't</code> for <code>cannot</code> can also be specified in this way. This flag is ignored in French.</p>
	<p lang="en">These modifications can also be applied to dependency structures.</p>
    <div id="sentType"></div>
    

<!-- *** Date *** -->
    <h2 lang="fr" id="dateFr">Date</h2><h2 lang="en" id="dateEn">Date</h2>
    <div lang="fr">
        <p><code>DT</code> accepte en paramètre soit une date sous forme d'une chaîne de caractères ou un <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Date">objet Javascript <code>Date</code></a>.La chaine de caractères en entrée doit être dans un format reconnu par la méthode <code>Date.parse()</code>, donc dans le format <a href="https://datatracker.ietf.org/doc/html/rfc2822#page-14">IETF-compliant RFC 2822</a> ou <a href="https://262.ecma-international.org/5.1/#sec-15.9.1.15">ISO8601</a>.</p>
        <p><strong>Attention:</strong> Le comportement de l'objet <code>Date()</code> diffère selon le navigateur. Il est fortement conseillé de fixer le fuseau horaire sinon il sera déterminé par le navigateur (voir ci-dessous). </p>
    </div>
    <div lang="en">
        <p><code>DT(...)</code> takes as parameter either a date as a <code>String</code> or a <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code> JavaScript object</a>.The input string must be a recognized format by <code>Date.parse()</code>: either <a href="https://datatracker.ietf.org/doc/html/rfc2822#page-14">IETF-compliant RFC 2822</a> or <a href="https://262.ecma-international.org/5.1/#sec-15.9.1.15">ISO8601</a> format.</p>
        <p><strong>Warning:</strong> The behavior of <code>Date()</code> depends on the browser. The timezone should be specified otherwise it might be given a different value according to the browser. </p>
    </div>

    <div id="dateCreation"></div>
    <div id="dateOption"></div>
    

<!-- *** Nombres *** -->
    <h2 lang="fr" id="nombres">Nombres</h2><h2 lang="en" id="numbers">Numbers</h2>
    <p lang="fr">On crée un nombre avec <code>NO(...)</code> dont le paramètre est soit un nombre entier ou réel ou une chaîne qui peut être analysée comme un nombre.</p>
    <p lang="en">A number is created with <code>NO(...)</code> whose parameter is either a number (integer or real) or a string that can be parsed as a number.</p>
    <div id="numberFormat"></div>
    <div id="numberAgreement"></div>
    

<!-- *** JavaScript *** -->
    <h2 lang="fr" id="javascript-fr">JavaScript</h2><h2 lang="en" id="javascript-en">JavaScript</h2>
    <h3 id="loadEnFr"><code>loadEn(trace), loadFr(trace), load(lang,trace)</code></h3> 
    <p lang="fr">Ces fonctions indiquent la langue à utiliser pour les prochaines réalisations. Il est important d'en appeler au moins une avant de débuter la réalisation d'une phrase; <code>lang</code> doit être <code>"en"</code> ou <code>"fr"</code>. Si le paramètre <code>trace</code> est <code>true</code>, (il est <code>false</code> par défaut) un message apparaîtra sur la console à la fin du chargement du lexique et de règles du langage.</p>
    <p lang="en">These functions sets the current realization language; one of them should be called before starting the realization process;  <code>lang</code> must be <code>"en"</code> or <code>"fr"</code>. If the parameter <code>trace</code> is <code>true</code>, (it is <code>false</code> by default), a message is written on the console after the loading of the lexicon and language rules.</p>
    <div lang="fr">Il est possible d'appeler ces fonctions aussi souvent que nécessaire pour changer le langage de réalisation courant.</div>
    <div lang="en">These functions can be called as often as necessary to change the current language.</div>
    <h3><code>.realize(lang)</code> / <code>.toString()</code></h3>
    <p lang="fr">Lance la réalisation d'un constituent, cette opération peut modifier la structure d'un ou plusieurs constituents. Si <code>lang</code> est spécifié, on appelle <code>load(lang)</code> avant la réalisation. Dans la grande majorité des cas la réalisation est plutôt obtenue par <code>.toString()</code> souvent appelée implicitement par le système lorsqu'une expression est utilisée dans un contexte de <code>string</code>. <br/>
    <code>.realize()</code> peut être utile lors de la mise au point dans certains environnements de programmation (e.g. Visual Studio Code) qui utilisent <code>.toString()</code> pour l'affichage et qui donc risque de changer la structure au cours de la mise au point. Pour éviter ces problèmes, il faut effectuer <code>Constituent.debug=true;</code> et <code>.toString()</code> affichera le source de l'expression, mais alors il faut demander la réalisation explicite avec <code>.realize()</code>.<br/>
    <b>Un conseil</b>: en programmation, toujours lancer la réalisation explicitement avec <code>.realize()</code>.
    </p>
    <p lang="en">Launch the realization of a constituent which in some cases modifies the structure of one or more constituents. If <code>lang</code> is specified, <code>load(lang)</code> is called before the realization. In the majority of cases, realization is instead obtained with <code>.toString()</code> often called implicitely by the system when an expression is used in a <code>string</code> context. <br/>
    <code>.realize()</code> can be useful when debugging in some programming environments  (e.g. Visual Studio Code) which call <code>.toString()</code> for displaying internal values and thus risk changing the constituents during debugging. To avoid theses situations, the following assignment <code>Constituent.debug=true;</code> can be used and  <code>.toString()</code> will display the source of the expression. But then realization is obtained by calling <code>.realize()</code> explicitly.</h3><br/>
    <b>Advice</b>: when programming, always launch realization explicitly with <code>.realize()</code>.
    <h3><code>.toSource(indent)</code></h3>
    <p lang="fr">Cette fonction retourne une version <em>chaîne</em> d'une expression <span class="jsr">jsRealB</span>, ceci peut être utile pour la mise au point d'une expression complexe. Si <code>indent</code> est spécifié (souvent 0) au premier appel à cette fonction, on obtient une expression indentée qui fait ressortir la structure de l'expression, si <code>indent</code> est absent, l'expression est sur une seule ligne.</p>
    <p lang="en">This function returns a <em>string</em> version of a  <span class="jsr">jsRealB</span> expression, this can be useful for debugging complex expressions. When <code>indent</code> is set (often 0) the the first call, the string is on multiple lines and indented to highlight the underlying structure. When <code>indent</code> is not given, the returned string is a single line.</p>
    <h3><code>getLanguage()</code></h3>
    <p lang="fr">Cette fonction retourne le langage courant de réalisation: <code>"fr"</code> pour le français et <code>"en"</code> pour l'anglais.</p>
    <p lang="en">This function returns the current realization language: <code>"fr"</code> for French and <code>"en"</code> for English.</p>
    <h3><code>.clone()</code></h3>
    <p lang="fr">Comme les options modifient le constituant dans toutes les utilisations subséquentes, il est souvent pratique de pouvoir garder la version originale pour la réutiliser et la modifier indépendamment. L'option <code>clone()</code> permet de copier un syntagme pour utilisation dans des contextes différents.</p>
    <p lang="en">As options modify the constituent for all following use, it is often useful to keep the original constituent and modify it independently. The <code>clone()</code> option allows reusing a constituent in different contexts.</p>
<div id="cloneUse"></div>
     <p lang="fr">Une alternative à <code>clone()</code> est d'associer une fonction à une variable, ce qui créera une nouvelle expression à chaque appel. Ceci permet de paramétrer l'expression, comme le nombre dans l'exemple suivant, mais qui sera au singulier par défaut. L'utilisation d'une <em>fonction fléchée</em> (<code>pommeFF</code>) simplifie la notation.</p>
     <p lang="en">AS an alternative to <code>clone()</code>, a function can be assigned to a variable. Each call to this function creates a new expression. This also allows parameterizing the expression, e.g. the number in the following example that is singular by default. The use of an <em>arrow function</em> (<code>appleAF</code>) simplifies the notation.</p>
<div id="functionUse"></div>
        
    <h3><code>.add(<em>element</em>,<em>position</em>)</code></h3>
        <p lang="fr">Ajout d'un nouveau syntagme <code>element</code> comme enfant à un syntagme existant. Le paramètre entier <code>position</code> est facultatif et spécifie la position (à partir de 0) dans le syntagme. Par défaut, l'élément est ajouté à la fin.</p>
        <p lang="en">Add a new phrase <code>element</code> as a child of an existing phrase. The second optional parameter <code>position</code> is an integer that specifies its position (counting from 0). By default, the element is added as the last child.</p>
    <div id="addUse"></div>
    
    <h3><code>.remove(<em>position</em>)</code></h3>
        <p lang="fr">Suppression du constituant à la position spécifiée en comptant à partir de 0.</p>
        <p lang="en">Remove the constituent at the given position starting from 0. </p>

    <h3><code>.nbConstituents()</code></h3>
        <p lang="fr">Retourne le nombre de constituents de la <code>Phrase</code> ou du <code>Dependent</code> actuel.</p>
        <p lang="en">Returns the number of constituents in the current <code>Phrase</code> or <code>Dependent</code></p>

    <h3><code>.nbConstituents()</code></h3>
        <p lang="fr">Retourne la liste des constituents de la <code>Phrase</code> ou du <code>Dependent</code> actuel.</p>
        <p lang="en">Returns the list of constituents in the current <code>Phrase</code> or <code>Dependent</code></p>
    
    <p lang="fr"><b><a href="http://www.iro.umontreal.ca/~lapalme/pyrealb/Hacking-pyrealb.html">Ce document (en anglais)</a> donne plus de détails sur la modification dynamique de constituents en pyrealb, mais s'applique aussi à <span class="jsr">jsRealB</span>.</b></p>
    <p lang="en"><b><a href="http://www.iro.umontreal.ca/~lapalme/pyrealb/Hacking-pyrealb.html">This document</a> gives more details on the dynamic constituent structure modification with pyrealb, but they can also be used in <span class="jsr">jsRealB</span>.</b></p>
<!-- *** Chargement dans une page web *** -->
    <h2 lang="fr" id="pageWeb">Chargement dans une page web</h2><h2 lang="en" id="webPage">Loading in a web page</h2>	
    <p lang="fr">Il suffit d'ajouter le script <code>jsRealB.js</code> du répertoire <code>dist</code> à la liste des scripts de la page. Ceci intègre déjà deux lexiques: français (plus de 52&nbsp;500 entrées) et anglais (plus de 33 &nbsp;900 entrées). Comme indiqué à la section <a href="#extensionVoc">Extension du vocabulaire</a>, il est facile d'ajouter de nouvelles entrées au lexique. </p>
    <p lang="en">It is only a matter of adding the script <code>jsRealB.js</code> to the scripts used by the web page. This includes two lexicons: English (33&nbsp;900 entries) and French (52&nbsp;500 entries). As shown below in the <a href="#vocExtension">Vocabulary extension section</a>, it is possible to add new entries to the lexicon or to change it completely.</p>
    <p lang="fr">Le script <code>jsRealB.js</code> exporte un seul objet <code>jsRealB</code> dont les champs sont les fonctions de <span class="jsr">jsRealB</span> qu'il est plus pratique d'ajouter à l'environnement global, sinon il faudra préfixer par <code>jsRealB.</code> tous les appels. Une manière pratique de le faire est avec l'expression <code>Object.assign(globalThis,jsRealB)</code> qui doit être exécutée avant toute fonction de <span class="jsr">jsRealB</span> sans préfixe. En particulier les fonctions de chargement de dictionnaire et de règles: <a href="#loadEnFr"><code>loadFr(...)</code></a> ou <a href="#loadEnFr"><code>loadEn(...)</code></a>.</p>
    <p lang="en">The <code>jsRealB.js</code> script exports a single object <code>jsRealB</code> whose fields are the <span class="jsr">jsRealB</span> functions which are more convenient to use when they are part of the global environment, otherwise <code>jsRealB.</code> should be added to each call. A simple way of doing this is by executing the expression <code>Object.assign(globalThis,jsRealB)</code> which should be executed before any <span class="jsr">jsRealB</span> function call without prefix. In particular any language and rule change: <a href="#loadEnFr"><code>loadFr(...)</code></a> ou <a href="#loadEnFr"><code>loadEn(...)</code></a>.  </p>
    
    <p lang="fr">Comme <span class="jsr">jsRealB</span> est construit avec de <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules">modules JavaScript</a>, plutôt que d'utiliser l'élément HTML <code>script</code>,  il est possible depuis un autre module d'accéder aux fonctions de réalisation en utilisant <code>import "./dist/jsRealB.js";</code>  qui a le même effet. Attention: <code>import</code> ne peut être utilisé que dans un script indiqué avec l'attribut <code>type="module"</code>.</p>    
    <p lang="en">As <span class="jsr">jsRealB</span> is built using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript modules</a>, instead of using the <code>script</code> HTML element,  it is also possible to access the realizing function using <code>import "./dist/jsRealB.js";</code>  from a JavaScript modul which has the same effect. Caution: the calling script tag must have the attribute <code>type="module"</code>.</p>    
    <p lang="fr">Idéalement, vous installerez votre propre version de <span class="jsr">jsRealB</span> à partir des sources du <a href="https://github.com/rali-udem/jsRealB">GitHub</a> et vous la référencerez depuis l'élément <code>script</code>. Mais vous pouvez aussi utiliser le module <em>npm</em> décrit à la prochaine section.</a>.</p>
    <p lang="en">Ideally you should install your own version of <span class="jsr">jsRealB</span> from the <a href="https://github.com/rali-udem/jsRealB">GitHub</a> sources and you will refer to it using a <code>script</code> element or use the <em>npm</em> module described in the next section.</a>.</p>

<!-- *** Module  *** -->
    <h2 lang="fr" id="moduleNode">Module <code>Node.js</code></h2><h2 lang="en" id="nodeModule"><code>Node.js</code> Module</h2>

    <p lang="fr"><span class="jsr">jsRealB</span> peut aussi être utilisé avec <code>Node.js</code> en important le module <code>jsRealB</code> avec  <code>import jsRealB from './jsRealB.js';</code> qui exporte le symbole <code>jsRealB</code>.  
        On peut aussi accéder au module <em>npm</em> <code>jsrealb</code> (attention à la casse différente), avec <code>import "jsrealb"</code> si, au préalable, on l'a installé avec <code>npm install jsrealb</code>. L'accès aux constructeurs de syntagmes du module Node doit se faire de la façon suivante <code>jsRealB.S(...)</code> ce qui peut s'avérer laborieux. Il est donc plus pratique de définir les constructeurs dans le contexte global en exécutant l'expressions suivante:</p>
    <p lang="en">The <span class="jsr">jsRealB</span> versions  can also be used with <code>Node.js</code> with an instruction such as <code>import "./dist/jsRealB.js";</code>. It is also possible to use the <em>npm</em> <code>jsrealb</code> (check for the differing capitalization), with <code>import "jsrealb"</code> if, beforehand, it has been installed on your machine with <code>npm install jsrealb</code>. Phrase constructors from the Node module must be called as <code>jsRealB.S(...)</code> which can be tedious. It is thus more convenient to define these constructors in the global namespace with the following expression:</p>
    <code>    Object.assign(globalThis,jsRealB);</code>
    <p lang="fr">Un script JavaScript peut vérifier s'il est utilisé comme module <code>Node.js</code> en consultant la variable booléenne <code>isRunningUnderNode</code>.</p>
    <p lang="en">A JavaScript script can check if it used as <code>Node.js</code> module with the boolean variable <code>isRunningUnderNode</code>.</p>

    <p lang="fr">Un exemple simple d'utilisation du module <code>Node.js</code> est ce <a href="../dist/jsRealB-filter.mjs">filtre Unix</a> qui accepte une expression <span class="jsr">jsRealB</span> sur une seule ligne et retourne sa réalisation en anglais. </p>
    <p lang="en">A simple example of the use of the <code>Node.js</code> module is this <a href="../dist/jsRealB-filter.mjs">Unix filter</a> which transforms a <span class="jsr">jsRealB</span> expression on a single line and returns the corresponding English realization.</p>

    <p lang="fr">Il est possible d'écrire des modules qui peuvent être exécutés en tant que module Node.js, mais aussi utilisés depuis un script dans une page web. <a href="../Examples/">Ce répertoire donne des exemples de patrons d'utilisation.</a></p>
    <p lang="en">It is possible to write Node.js modules that can also be used from web page script. <a href="../Examples/">This directory shows some code patterns illustrating different use cases.</a></p>
</ul>

<!-- *** Gestion des lexiques *** -->
    <h2 lang="fr" id="extensionVoc">Gestion des lexiques</h2><h2 lang="en" id="vocExtension">Lexicon Management</h2>
<p lang="fr"> <span class="jsr">jsRealB</span> 
intègre déjà deux lexiques assez détaillés: français (plus de 52 500 entrées) et anglais (plus de 34 200 entrées) qu'il est possible de consulter et de modifier à l'aide des fonctions suivantes. Lorsque <code>lang</code> (<code>"en"</code> ou <code>"fr"</code>) est spécifié, la fonction s'applique au lexique de cette langue, sinon au lexique courant, celui du dernier appel à <code>loadEn()</code> ou <code>loadFr()</code>.
</p>
<p lang="en"> <span class="jsr">jsRealB</span> 
provides already two comprehensive lexicons: French (more than 52 500 entries) and English (more than 34 200 entries) that can be queried and modified with the following functions. When <code>lang</code> (<code>"en"</code> or <code>"fr"</code>) is specified, the function is applied to the lexicon of this language, otherwise it applies to the current lexicon, the one of the last call to <code>loadEn()</code> or <code>loadFr()</code>.
</p>

<h3><code>addToLexicon(lemma[,newInfos][,lang])</code></h3>
<p lang="fr"> 
     <code>lemma</code> est l'entrée de base et <code>newInfos</code> est l'information morphologique selon le format interne à <span class="jsr">jsRealB</span>: un objet indiquant le ou les catégories possibles et pour chaque catégorie, des propriétés et la table de déclinaison ou conjugaison correspondantes.
    Par exemple, <code>addToLexicon("jsRealB",{"N":{"g":"m", "pe":3, "tab": "nI"})</code> ajoutera le mot <code>jsRealB</code> comme nom masculin invariable au lexique courant. 
    Cette fonction peut aussi être appelée avec un seul paramètre qui est un objet dont la clé est le lemme. L'exemple précédent peut donc s'écrire: <code>addToLexicon({"jsRealB":{"N":{"g":"m", "pe":3, "tab": "nI"}})</code>.  
</p>
<ul lang="fr">
<li>Si le lemme et la catégorie existent déjà dans le lexique, alors l'entrée pour cette catégorie est remplacée par <code>newInfos</code>. </li>
<li>Cette fonction retourne l'entrée modifiée pour <code>lemma</code>.</li>
<li><a href="http://www.iro.umontreal.ca/~lapalme/pyrealb/Lexicon-Format-fr.html">Plus d'information sur le format du lexique</a>.</li> 
<li>Pour déterminer les informations à ajouter, le plus simple est de copier les informations d'un mot du lexique qui se conjugue ou se décline de la même façon. L'<a href="http://rali.iro.umontreal.ca/JSrealB/current/demos/Evaluation/index.html">IDE de jsRealB</a> permet de consulter les informations du lexique.
</li>
<li>Pour enlever une entrée d'un lexique, il de mettre <code>newInfos</code> à <code>null</code>.</li>
</ul>

<p lang="en"> 
     <code>lemma</code> is the basic form and <code>newInfos</code> is the morphologic information according to the internal  <span class="jsr">jsRealB</span> format: an object indicating one or many possible categories. For each category, properties and declension or conjugation are given.
    For example, <code>addToLexicon("jsRealB",{"N":{"g":"m", "pe":3, "tab": "nI"})</code> will add the <code>jsRealB</code> as a masculine invariable word. This function can also be called with a single parameter: an object whose key is the lemma. The previous example could also have been written: <code>addToLexicon({"jsRealB":{"N":{"g":"m", "pe":3, "tab": "nI"}})</code>.  
</p>

<ul lang="en">
	<li>If the lemma and category are already present in the lexicon, then the category of this entry is replaced by <code>newInfos</code>.</li> 
<li>This function returns the new modified lexicon entry for <code>lemma</code>.</li>
<li><a href="http://www.iro.umontreal.ca/~lapalme/pyrealb/Lexicon-Format-en.html">More information about the lexicon format</a>.</li>
<li>In order to find the informations to add, the simplest way is to copy the lexicon information for a similar word already in the lexicon. 
The <a href="http://rali.iro.umontreal.ca/JSrealB/current/demos/Evaluation/index.html">jsRealB IDE</a> provides access to the lexicon information.
</li>
<li>To remove an entry, set <code>newInfos</code> to <code>null</code>.</li>
</ul>

<h3><code>getLemma(lemma[,lang])</code></h3>
<p lang="fr">Retourner les informations du lexique correspondant à <code>lemma</code>. </p>
<p lang="en">Return lexicon information to <code>lemma</code>. </p>

<h3><code>updateLexicon(newLexicon[,lang])</code></h3>
<p lang="fr">Fusionner les entrées de <code>newLexicon</code> avec le lexique spécifié. Ceci ajoutera les nouvelles entrées et remplacera les entrées existantes par celles du nouveau lexique. La fusion est effectuée au niveau des entrées, mais non des catégories.</p>
<p lang="en">Merge the entries of <code>newLexicon</code> with the specified lexicon. This adds the new entries and replaces the existing entries by the ones of the new lexicon. Merging is done at the entry level, not at the category level.</p>

<h3><code>getLanguage()</code></h3>
<p lang=fr>Retourne le langage de réalisation courant.</p>
<p lang=en>Returns the current realization language.</p>

<h3><code>getLexicon()</code></h3>
<p lang="fr">Retourne le lexique courant.</p>
<p lang="en">Returns the current lexicon.</p>

<h3><code>setQuoteOOV(value)</code></h3>
<p lang="fr">Lorsque cet identificateur est mis à <code>true</code>, les mots absents du lexique sont considérés comme des chaînes verbatim (i.e. <code>Q(...)</code> au lieu de susciter un avertissement et d'être affichés entre double crochets. Comme ceci empêche toute lemmatisation, accord ou transformation de phrases, il faut utiliser cet indicateur avec parcimonie.</p>
<p lang="en">When this flag is set to <code>true</code>, words that are not in the lexicon are considered as quoted strings (i.e. <code>Q(...)</code> instead of raising an warning and be displayed between double square brackets. As this prevents any lemmatization, agreement or sentence transformations, this flag should be used sparingly.</p>

<h3><code>buildLemmataMap(lang)</code></h3>
<p lang="fr">Créer une table (une <code>Map</code> et non un objet Javascript). Chaque clé est une des formes déclinées ou conjuguées de tous les mots du lexique de la langue spécifiée. La valeur associée à une liste d'instances de <code>Terminal</code> qui sont réalisées par la clé.</p>
<p lang="fr">Cette <code>Map</code> peut être utilisée pour de la génération <i>inverse</i>. Voici quelques appels suivis des résultats après &rAarr;<pre lang="fr"><code>    const lemmataFr = buildLemmataMap("fr")
    lemmataFr.get("finies").map(e=>e.toSource()) &rAarr; <i>[A('fini').g("f").n("p"), V('finir').t("pp").g("f").n("p")]</i>
    lemmataFr.get("crus").filter(e=>e.isA("N")).map(e=>e.toSource()) &rAarr; <i>[`N('cru').n("p")`]</i>
</code></pre></p>

<p lang="en">Build a table (a <code>Map</code>, not a Javascript object). Each key is an inflected form of all the entries in the lexicon of the specified language. The associated value is a list of <code>Terminal</code> instances that are realized by the key.</p>
<p lang="en">This <code>Map</code>  can be used for <i>inverse</i> generation. Here are examples of calls with the result shown after &rAarr;<pre lang="en"><code>    const lemmataEn = buildLemmataMap("en")
    lemmataEn.get("love").map(e=>e.toSource()) &rAarr; <i>[N('love'), V('love').t("b"), V('love').pe(1), V('love').pe(2), V('love').pe(1).n("p"), V('love').pe(2).n("p"), V('love').n("p")]</i>
    lemmataFr.get("love").filter(e=>e.isA("N")).map(e=>e.toSource()) &rAarr; <i>[N('love')]</i>
</code></pre></p>


<!-- *** Sélection de variantes *** -->
<h2 lang="fr" id="selectionVar">Sélection de variantes</h2><h2 lang="en" id="varSelection">Variant selection</h2>
<h3><code>oneOf(e<sub>1</sub>,e<sub>2</sub>,...)</code></h3>
<p lang="fr">
où <code>e<sub>i</sub></code> est est une valeur, choisit un <code>e<sub>i</sub></code> au hasard. En <span class="jsr">jsRealB</span>, ces éléments sont souvent des constructeurs correspondant à des structures de phrases différentes. Si <code>e<sub>1</sub></code> est un tableau alors la sélection est faite dans ce tableau, en ignorant les autres paramètres.
</p>
<p lang="fr">Pour éviter que tous les éléments soient évalués avant la sélection, il suffit de <em>fonctionaliser</em> l'expression en une fonction sans paramètre en la préfixant par <code>()=></code>, ce qui en fait une <em>fonction fléchée</em>. Une fois l'élément choisi, <code>oneOf</code> vérifie si la valeur est une fonction et si c'est le cas, il retourne le résultat de l'appel. Par exemple,
<code>oneOf(()=>N("amour"),()=>N("amitié"))</code> permet de choisir entre les deux noms sans évaluer les deux constructeurs. Dans ce cas, très simple, il aurait été aussi possible d'écrire <code>N(oneOf("amour","amitié"))</code>.
</p>
<p lang="fr"><code>oneOf</code> implante le <a href="https://rosaenlg.org/rosaenlg/4.3.0/mixins_ref/synonyms.html#_choose_randomly_but_try_not_to_repeat" target="_blank">"mode:once" de RosaeNLG</a>: une alternative est choisie au hasard, mais en essayant de ne pas répéter la précédente. Lorsque toutes les alternatives ont été utilisées, le système recommence avec toutes les alternatives initiales, mais en évitant la dernière utilisée afin de ne pas se répéter.</p>
<p lang="en">
where <code>e<sub>i</sub></code> is a value, selects randomly a <code>e<sub>i</sub></code>. In <span class="jsr">jsRealB</span>, these elements are often constructors corresponding to different phrase structures. If <code>e<sub>1</sub></code> is an array, the selection is performed within this array, ignoring other parameters.
</p>
<p lang="en">To avoid the evaluation of all elements before the selection, it is possible to <em>functionalize</em> a expression into a function with no formal parameter by prefixing it with <code>()=></code> which makes it an <em>arrow function</em>. Once the element is selected, <code>oneOf</code> checks if the value is a function and, if it is so, it returns the value of the called function. For exemple,
<code>oneOf(()=>V("love"),()=>V("like"))</code> allows choosing between the two verbs without evaluating both constructors. In this simplistic case, this could have also been written as <code>V(oneOf("love","like"))</code>.</p>
<p lang="en"><code>oneOf</code> implements the <a href="https://rosaenlg.org/rosaenlg/4.3.0/mixins_ref/synonyms.html#_choose_randomly_but_try_not_to_repeat"  target="_blank">"mode:once" of RosaeNLG</a>: it selects an alternative randomly, but tries not to repeat the same one. When all alternatives have been triggered, it resets but tries not run the last triggered alternative, avoiding repetitions.</p>

<h3><code>choice(e<sub>1</sub>,e<sub>2</sub>,...)</code></h3>
<p lang="fr">Version de la fonction <code>oneOf</code> qui choisit une alternative sans tenir compte des choix précédents. C'est la méthode <i>classique</i> d'effectuer des choix aléatoires.</p>
<p lang="en">Version of <code>oneOf</code> that selects an alternative into account without taking previous choices. This is the <i>classic</i> implementation for making random choices.</p>

<h3><code>mix(e<sub>1</sub>,e<sub>2</sub>,...)</code></h3>
<p lang="fr">
<i>permute</i> ses paramètres, ce qui peut être utile pour varier l'ordre des éléments. Si <code>e<sub>1</sub></code> est un tableau alors la sélection est faite dans ce tableau, en ignorant les autres paramètres. Comme pour <code>oneOf(...)</code>, pour éviter que tous les éléments soient évalués avant la sélection, il suffit de <em>fonctionaliser</em> l'expression en une fonction sans paramètre en la préfixant par <code>()=></code>, ce qui en fait une <em>fonction fléchée</em>. Pour chaque élément de la liste permutée, <code>mix</code> vérifie si sa valeur est une fonction et si c'est le cas, il le remplace par le résultat de l'appel.
</p>
<p lang="en">
<i>shuffles</i> its parameters, which can be useful to vary the order of elements. If <code>e<sub>1</sub></code> is an array, the selection is performed within this array, ignoring other parameters. As for <code>oneOf(...)</code>, to avoid the evaluation of all elements before the selection, it is possible to <em>functionalize</em> a expression into a function with no formal parameter by prefixing it with <code>()=></code> which makes it an <em>arrow function</em>. 
For each element in the mixed list, <code>mix</code> checks if its value is a function and, if so, it inserts the value of the called function in the resulting list.
</p>
    

<h2 lang="fr" id="traitementsJSON">Traitement en JSON</h2><h2 lang="en" id="JSONprocessing">JSON processing</h2>
<p lang="fr">Pour faciliter l'utilisation de <span class="jsr">jsRealB</span> en sortie d'un système externe. Il est possible d'utiliser un format d'entrée JSON <a href="jsRealB-jsonInput.html">décrit dans ce document (en anglais)</a> où sont décrites deux API permettant d'appeler un serveur <span class="jsr">jsRealB</span> <a href="jsRealBfromPython.html">depuis un programme Python</a> ou Prolog. Il est également possible d"obtenir une expression JSON correspondant à une expression <span class="jsr">jsRealB</span>.
</p>
<p lang="en">To simplify the use of <span class="jsr">jsRealB</span> as output of an external system, a JSON input format has been defined. <a href="jsRealB-jsonInput.html">It is described in this document.</a> in which two APIs are described for calling a <span class="jsr">jsRealB</span> server <a href="jsRealBfromPython.html">from Python</a> or Prolog. It is also possible to obtain the JSON expression corresponding to a given <span class="jsr">jsRealB</span> expression.
</p>

<h2 lang="fr" id="Gestion des avertissements">Gestion des avertissements</h2><h2 lang="en" id="Warning management">Warning Management</h2>
<p lang="fr">Lorsque <span class="jsr">jsRealB</span> détecte une erreur de réalisation, un avertissement est écrit sur la console JavaScript avec la fonction <code>console.warn()</code>. Le système réalise alors le lemme courant entouré de doubles crochets. Il est possible de modifier ce comportement afin de lever une exception au premier avertissement ou pour récupérer la liste des avertissements générés. Ce pourrait permettre de les afficher dans la page web, si la console JavaScript n'est pas accessible. Les fonctions suivantes permettent de gérer ces avertissements</p>
<p lang="en">When <span class="jsr">jsRealB</span> detects a realization error, a warning is written on the JavaScript console using  <code>console.warn()</code>. The lemma is then wrapped within double brackets. This behavior can be modified for raising an exception at the first warning or for getting back a list of warnings. It this then possible to display them in the web page if the JavaScript console is hidden. The following functions handle the warnings:</p>
<h3><code>setExceptionOnWarning(val)</code></h3>
<p lang="fr"><code>val</code> est un booléen qui indique si oui ou non, une exception sera levée lors de l'émission d'un avertissement</p>
<p lang="en"><code>val</code> is a boolean indicating if an exception is raised when a warning is emitted.</p>
<h3><code>resetSavedWarnings()</code></h3>
<p lang=fr>Réinitialiser la liste des avertissements.</p>
<p lang=en>Reset the list of warnings.</p>
<h3><code>getSavedWarnings()</code></h3>
<p lang="fr">Récupérer la liste des avertissements, depuis le dernier appel à <code>resetSavedWarnings</code> sans modifier la liste. Une liste vide indique qu'aucun avertissement n'a été émis.</p>
<p lang="en">Get the list of warnings since the last call to <code>resetSavedWarnings</code> without changing the list. An empty list indicates that no warnings were emitted.</p>

<h2 lang="fr" id="implantation">Informations sur l'implantation</h2><h2 lang="en" id="implementation">Informations about the implementation</h2>
<h3><code>jsRealB_version</code></h3>
<p lang=fr>Indique le numéro de version de <span class="jsr">jsRealB</span>, actuellement: <code class="version-no"></code></p>
<p lang=en>Gives the version number of <span class="jsr">jsRealB</span>, currently: <code class="version-no"></code></p>

<h3><code>jsRealB_dateCreated</code></h3>
<p lang="fr">Indique la date de la création de la version courante de <span class="jsr">jsRealB</span>, 
    actuellement: <code class="version-date"></code></p>
<p lang="en">Gives the creation date of the current <span class="jsr">jsRealB</span>,
    currently: <code class="version-date"></code></p>

<h3><code>isRunningUnderNode</code></h3>
<p lang="fr">Booléen  qui indique si le script <span class="jsr">jsRealB</span> a été appelé par <code>Node.js</code>.</p>
<p lang="en">Boolean indicating if the current <span class="jsr">jsRealB</span> has been called by <code>Node.js</code>.</p>
<!-- *** Informations complémentaires *** -->
    <h2 lang="fr" id="plusDinfo">Informations complémentaires</h2><h2 lang="en" id="moreInfo">More Information</h2>
<ul>
	<li><a href="https://arxiv.org/pdf/2012.15425" lang="fr">Document, en anglais, décrivant l'organisation de <span class="jsr">jsRealB</span></a><a href="https://arxiv.org/pdf/2012.15425" lang="en">Document describing the organization of <span class="jsr">jsRealB</span></a></li>
	<li><a href="http://rali.iro.umontreal.ca/rali/sites/default/files/publis/jsRealB-presentation.pdf" lang="fr">Présentation de jsRealB - Février 2022</a> <a href="https://drive.google.com/file/d/1U-kk-xAx9bLj6k1ZO9ruY4dMDQBlkRRu/view?usp=sharin√g" title="GMT20220223-163036_Recording_2560x1440.mp4 - Google Drive" lang="fr">[enregistrement]</a><a href="http://rali.iro.umontreal.ca/rali/sites/default/files/publis/jsRealB-presentation.pdf" lang="en">Presentation of jsRealB (in French) - February 2022</a> <a href="https://drive.google.com/file/d/1U-kk-xAx9bLj6k1ZO9ruY4dMDQBlkRRu/view?usp=sharing" title="GMT20220223-163036_Recording_2560x1440.mp4 - Google Drive" lang="en">[recording]</a></li>
    <li><a href="http://rali.iro.umontreal.ca/rali/?q=fr/jsrealb-realisateur-bilingue-de-texte" lang="fr">Historique des versions et démonstrations</a><a href="http://rali.iro.umontreal.ca/rali/?q=en/jsrealb-bilingual-text-realiser" lang="en">Previous versions and demos</a></li>
    <li><a href="https://observablehq.com/@lapalme/nouvelles-experiences-avec-jsrealb" title="Nouvelles exp&#xE9;riences avec jsRealB / Guy Lapalme / Observable" lang="fr">Notebook Observable</a><a href="https://observablehq.com/@lapalme/exprimenting-with-jsrealb" title="Experimenting with jsRealB / Guy Lapalme / Observable" lang="en">Observable Notebook</a></li>
    <li><a href="http://rali.iro.umontreal.ca/JSrealB/current/demos/Evaluation/index.html" lang="fr">Edition et réalisation d'une expression <span class="jsr">jsRealB</span></a><a href="http://rali.iro.umontreal.ca/JSrealB/current/demos/Evaluation/index.html" lang="en">Edition and realization of a <span class="jsr">jsRealB</span> expression</a></li>
    <li><a href="../IDE/README.html">Interactive Development Environment</a></li>
    <li><a href="http://rali.iro.umontreal.ca/JSrealB/current/Tutorial/tutorial.html" title="jsRealB tutorial" lang="fr">Tutoriel (en anglais)</a><a href="http://rali.iro.umontreal.ca/JSrealB/current/Tutorial/tutorial.html" title="jsRealB tutorial" lang="en">Tutorial</a></li>
    <li><a href="https://github.com/rali-udem/JSrealB" lang="fr">Dépot GitHub</a><a href="https://github.com/rali-udem/JSrealB" lang="en">GitHub repository</a></li>
    <li><a href="./Lexicon-Format-fr.md" lang="fr">Format des entrées de lexiques (en anglais)</a><a href="./Lexicon-Format-en-md" lang="en">Format of the lexicon entries</a></li>
    <li>Publications:
        <ul>
            <li><a href="https://aclanthology.org/W15-4719/">Demo paper at ENLG-2015</a></li>
            <li>Daoust, N., and G. Lapalme, <em>JSreal: A Text Realizer for Web Programming</em>, Language Production, Cognition, and the Lexicon - a Festschrift in honor of Michael Zock, Text, Speech and Language Technology, Vol 48: Springer, pp. 363-378, 2014. [<a href="http://rali.iro.umontreal.ca/rali/sites/default/files/publis/JSreal.pdf">PDF</a>]</li>
        </ul>
    </li>
</ul>

<footer>Contact: <a href="mailto:lapalme@iro.umontreal.ca">Guy Lapalme</a> <a href="http://rali.iro.umontreal.ca">RALI</a>, Université de Montréal, CANADA. 2023.
</footer>
</body>
</html>
