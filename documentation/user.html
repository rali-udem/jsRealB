<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <title>jsRealB (V 3.4) - Documentation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="style.css">
    <!-- <script src="../dist/jsRealB.js"></script> -->
<!-- to ease debugging we load each file separately -->
        <script src="../data/lexicon-en.js"></script>
        <script src="../data/rule-en.js"></script>
        <script src="../data/lexicon-fr.js"></script>
        <script src="../data/rule-fr.js"></script>
        <script src="../data/lexicon-fr.js"></script>
        <script src="../data/rule-fr.js"></script>
        <script src="../build/Utils.js"></script>
        <script src="../build/Constituent.js"></script>
        <script src="../build/Phrase.js"></script>
        <script src="../build/Terminal.js"></script>
        <script src="../build/Date.js"></script>
        <script src="../build/Number.js"></script>
        <script src="../build/Warnings.js"></script>
<!-- end of separate loading -->
    <script src="https://code.jquery.com/jquery-latest.min.js"></script>
    <script src="user.js"></script>
    <script src="user-infos.js"></script>
</head>
<body>
<!-- top menus -->
    <span class="dropdown" id="quicklinks">
      <span lang="fr">Aller à ↓</span><span lang="en">Goto ↓</span>
      <span class="dropdown-content"></span>
    </span>
    <span id="langSelect">[<span lang="en">FR</span><span lang="fr">EN</span>]</span>
<!-- start of page  -->
    <h1><span class="jsr">jsRealB (Version 3.4)</span> - Documentation</h1>
    <p lang="fr"><span class="jsr">jsRealB</span> est un réalisateur de texte pour l'anglais et le français écrit en Javascript. Il peut être utilisé soit à l'intérieur d'une page web comme celle-ci dont tous les exemples sont réalisés dynamiquement, ou comme module <code>Node.js</code>.</p>
    <p lang="en"><span class="jsr">jsRealB</span> is a text realizer for French and English written in Javascript. It can be used either within a web page such as this one whose examples are dynamically realized or as a <code>Node.js</code> module.</p>

<!-- *** Constituants *** -->
    <h2 lang="fr" id="constituants">Constituants</h2><h2 lang="en" id="constituents">Constituents</h2>
    <div id="terminalsSect"></div>
    <div id="syntagmesSect"></div>
    <div lang="fr">
        <p>Les accords <em>simples</em> sont effectués entre les constituants d'un syntagme. Un constituant est considéré comme la <i>tête</i> avec lequel les autres sont accordés. La <i>tête</i> est déterminée de la façon suivante:</p>
        <ul>
            <li><code>NP</code>: le premier <code>N</code> ou <code>NP</code> en tenant compte de la modification possible par un <code>NO</code>, cet accord est propagé à une subordonnée interne au <code>NP</code>;</li>
            <li><code>AP</code>: le premier <code>A</code>;</li>
            <li><code>VP</code>: le premier <code>V</code>;</li>
            <li><code>S</code>, <code>SP</code>: accord avec le <em>sujet</em>, soit le premier <code>NP</code>, <code>N</code>, 
                <code>Pro</code> ou <code>CP</code>. Si le <code>Pro</code> est un pronom relatif, le <em>sujet</em> de la subordonnée est utilisé. Des tests spécifiques permettent d'accorder le verbe <code>être/be</code> ainsi que pour tenir compte des sujets coordonnés.</li>
        </ul>
        <p>Des options (section suivante) spécifiant le genre et le nombre l'emportent sur ces accords automatiques.</p>
    </div>

    <div lang="en">
        <p><em>Simple</em> agreements are dealt with between constituents of a phrase. A constituent is taken as the <i>head</i> with which others agree. The <i>head</i> is found as follows:</p>
        <ul>
            <li><code>NP</code>: the first <code>N</code> or <code>NP</code> taking into account an eventual <code>NO</code>, this agreement is propagated to an internal subordinate phrase;</li>
            <li><code>AP</code>: the first <code>A</code>;</li>
            <li><code>VP</code>: the first <code>V</code>;</li>
            <li><code>S</code>, <code>SP</code>: agrees with the <em>subject</em>, taken as the first <code>NP</code>, <code>N</code>, 
                <code>Pro</code> or <code>CP</code>. If the <code>Pro</code> is a relative pronoun, the <em>subject</em> of the subordinate is taken. Specific tests take into account the verbs <code>être/be</code> and the coordinate subjects.</li>
        </ul>
        <p>Options (next section) can override these automatic agreements.</p>
    </div>
    

<!-- *** Déclinaisons et conjugaisons *** -->
    <h2 id="optionsFr" lang="fr">Déclinaisons et conjugaisons</h2><h2 id="optionsEn" lang="en">Declension and conjugation</h2>
    <div id="optionsSect"></div>
    <p lang="en">Perfect and  continuous tenses for verbs can obtained by setting the <a href="#sentType">sentence type</a> to <code>.typ({perf:true})</code> or <code>.typ({prog:true})</code> </p>
    

<!-- *** Pronoms *** -->
    <h2 lang="fr" id="pronoms">Pronoms</h2><h2 lang="en" id="pronouns">Pronouns</h2>
    <p lang="fr">Le pronoms qui sont dans le lexique sont à la 1ère personne du singulier. Pour obtenir les autres, il faut
    spécifier la personne, le nombre et éventuellement le genre. Ce mécanisme s'applique aussi pour les
    pronoms <code>me</code> et <code>moi-même</code> et pour le déterminant <code>mon</code>.</p>
    <p lang="en">Pronouns in the lexicon are at the first person singular. To get the other forms, the gender, the number and
    the person must be specified. The same option mechanism can be used for the pronouns <code>mine</code> and <code>myself</code> and
    for the determiner <code>my</code>.</p>
    <div id="pronomsSect"></div>
    
    <div id="pronomsSect2">
        <h3><span lang="fr">Pronoms en modifiant la forme tonique</span>
            <span lang="en">Pronouns from the tonic form</span>
        </h3>
        <div lang="fr">
            <ul>
                <li>la forme tonique <code>.tn(..)</code> avec comme paramètre 
                    <ul>
                        <li><code>""</code>: pour la forme tonique elle-même</li>
                        <li><code>refl</code> pour obtenir la forme réflexive (terminant en
                     <code>-même</code>)</li>
                    </ul>
                 </li>
                <li>la forme clitique <code>.c(..)</code> avec comme paramètre 
                    <ul>
                        <li><code>nom</code> pour la forme nominative</li>
                        <li><code>acc</code> pour la forme accusative (complément d'objet direct)</li>
                        <li><code>dat</code> pour la forme datif (complément d'objet indirect)</li>
                        <li><code>nom</code> pour la forme réfléchie</li>
                    </ul>
                </li>
            </ul>
            <p>Le tableau suivant présente la forme obtenue au-dessus de la spécification <span class="jsr">jsRealB</span>.</p>
            <div id="pronomsTon"></div>
            <p>Le tableau suivant présente les pronoms possessifs qui s'accordent en genre et en nombre.</p>
            <div id="pronomsPoss"></div>
            <p>Les déterminants possessifs varient en genre et en nombre à partir de leur 
            forme de base comme le montre le tableau suivant.</p>
            <div id="determinantsPoss"></div>
        </div>
        <div lang="en">
           <ul>
               <li>tonic form <code>.tn(..)</code> with parameter
                   <ul>
                       <li><code>""</code>: for the tonic form itself</li>
                       <li><code>refl</code> to get the reflexive form (ending with
                            <code>self</code>)</li>
                   </ul>
                </li>
               <li>clitic form <code>.c(..)</code> with options:
                   <ul>
                       <li><code>nom</code> for the nominative</li>
                       <li><code>acc</code> for the accusative (direct object)</li>
                       <li><code>dat</code> for the dative (indirect object)</li>
                       <li><code>geb</code> for the genitive (noun complement)</li>
                   </ul>
               </li>
           </ul>
           <p>The following table shows the realized form above the corresponding 
               <span class="jsr">jsRealB</span> expression.</p>
            <div id="tonicPro"></div>
            <p>Possessive determiners are specified by giving options for the number, the person, 
                the gender (when at the third person) and also if the owner (<code>.ow(..)</code>) 
                is singular or plural. The following table shows the realization above its 
                jsRealB specification.
             </p>
            <div id="possDet"></div>
        </div>
    </div>
    

<!-- *** Mise en forme *** -->
    <h2 lang="fr" id="formattage">Mise en forme</h2><h2 lang="en" id="formatting">Formatting</h2>
    <p lang="fr">Si l'ajout avant et/ou après un constituent correspond à un signe de ponctuation défini dans les règles, l'espacement approprié est ajouté avant et après le signe, sinon la chaîne est ajoutée telle quelle sans espacement.</p>
    <p lang="en">If the content added before and/or a constituent is defined in the language rules, then the appropriate spacing is added before and after the punctuation sign, otherwise the content is added without spacing.</p>
    <div id="formatSect"></div>
    

<!-- *** Modification du syntagme nominal *** -->
    <h2 lang="fr" id="modSN">Modification du syntagme nominal</h2><h2 lang="en" id="npMod">Noun phrase modification</h2>
    <div id="nPmods"></div>
    

<!-- *** Modification du type de phrase *** -->
    <h2 lang="fr" id="changeType">Modification du type de phrase</h2><h2 lang="en" id="typeChange">Sentence type modification</h2>
    <p lang="fr">Les phrases sont construites à la forme active, mais il est possible d'en modifier le type pour obtenir des phrases négatives, progressives, interrogatives ou passives.  Ces modifications sont de la forme <code>S(...).typ({...})</code> Il est possible de combiner plusieurs modifications en spécifiant plusieurs paires clés-valeurs dans l'objet paramètre de <code>type</code>. L'utilisation de contractions en anglais telles que <code>I'll</code> pour <code>I will</code> ou <code>can't</code> pour <code>cannot</code> peut aussi être spécifiée de cette manière, mais cet indicateur est ignoré en français.</p>
    <p lang="en">Sentences are built at the active voice, but their type can be modified in order to get negative, progressive, interrogative or passive sentences. These modifications are indicated by <code>S(...).typ({...})</code>. Modifications can be combined by specifying multiple key value pairs in the object which is the parameter of <code>type</code>. The use of contractions such as <code>I'll</code> for <code>I will</code> or <code>can't</code> for <code>cannot</code> can also be specified in this way. This flag is ignored in French.</p>
    <div id="sentType"></div>
    

<!-- *** Date *** -->
    <h2 lang="fr" id="dateFr">Date</h2><h2 lang="en" id="dateEn">Date</h2>
    <div lang="fr">
        <p><code>DT</code> accepte en paramètre soit une date sous forme d'une chaîne de caractères ou un <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Date">objet Javascript <code>Date</code></a>.La chaine de caractères en entrée doit être dans un format reconnu par la méthode <code>Date.parse()</code>, donc dans le format <a href="https://tools.ietf.org/html/rfc2822#page-14">IETF-compliant RFC 2822</a> ou <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15">ISO8601</a>.</p>
        <p><strong>Attention:</strong> Le comportement de l'objet <code>Date()</code> diffère selon le navigateur. Il est fortement conseillé de fixer le fuseau horaire sinon il sera déterminé par le navigateur (voir ci-dessous). </p>
    </div>
    <div lang="en">
        <p><code>DT(...)</code> takes as parameter either a date as a <code>String</code> or a <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Date"><code>Date</code> javascript object</a>.The input string must be a recognized format by <code>Date.parse()</code>: either <a href="https://tools.ietf.org/html/rfc2822#page-14">IETF-compliant RFC 2822</a> or <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15">ISO8601</a> format.</p>
        <p><strong>Warning:</strong> The behavior of <code>Date()</code> depends on the browser. The timezone should be specified otherwise it might be given a different value according to the browser. </p>
    </div>

    <div id="dateCreation"></div>
    <div id="dateOption"></div>
    

<!-- *** Nombres *** -->
    <h2 lang="fr" id="nombres">Nombres</h2><h2 lang="en" id="numbers">Numbers</h2>
    <p lang="fr">On crée un nombre avec <code>NO(...)</code> dont le paramètre est soit un nombre entier ou réel ou une chaîne qui peut être analysée comme un nombre.</p>
    <p lang="en">A number is created with <code>NO(...)</code> whose parameter is either a number (integer or real) or a string that can be parsed as a number. In English, numbers less than one hundred written in letters can also be used as input.</p>
    <div id="numberFormat"></div>
    <div id="numberAgreement"></div>
    

<!-- *** JavaScript *** -->
    <h2 lang="fr" id="javascript-fr">JavaScript</h2><h2 lang="en" id="javascript-en">JavaScript</h2>
    <h3><code>.clone()</code></h3>
    <p lang="fr">Comme les options modifient le constituant dans toutes les utilisations subséquentes, il est souvent pratique de pouvoir garder la version originale pour la réutiliser et la modifier indépendamment. L'option <code>clone()</code> permet de copier un syntagme pour utilisation dans des contextes différents.</p>
    <p lang="en">As options modify the constituent for all following use, it is often useful to keep the original constituent and modify it independently. The <code>clone()</code> option allows reusing a constituent in different contexts.</p>
<div id="cloneUse"></div>
     <p lang="fr">Une alternative à <code>clone()</code> est d'associer une fonction à une variable, ce qui créera une nouvelle expression à chaque appel. Ceci permet de paramétrer l'expression, comme le nombre dans l'exemple suivant, mais qui sera au singulier par défaut. L'utilisation d'une <em>fonction fléchée</em> (<code>pommeFF</code>) simplifie la notation.</p>
     <p lang="en">AS an alternative to <code>clone()</code>, a function can be assigned to a variable. Each call to this function creates a new expression. This also allows parameterizing the expression, e.g. the number in the following example that is singular by default. The use of an <em>arrow function</em> (<code>appleAF</code>) simplifies the notation.</p>
<div id="functionUse"></div>
        
    <h3><code>.add(<em>element</em>,<em>position</em>)</code></h3>
        <p lang="fr">Ajout d'un nouveau syntagme <code>element</code> comme enfant à un syntagme existant. Le paramètre entier <code>position</code> est facultatif et spécifie la position (à partir de 0) dans le syntagme. Par défaut, l'élément est ajouté à la fin.</p>
        <p lang="en">Add a new phrase <code>element</code> as a child of an existing phrase. The second optional parameter <code>position</code> is an integer that specifies its position (counting from 0). By default, the element is added as the last child.</p>
<div id="addUse"></div>
    <h3><code>.toSource()</code></h3>
    <p lang="fr">Cette fonction retourne une version <em>chaîne</em> d'une expression <span class="jsr">jsRealB</span>, ceci peut être utile pour la mise au point d'une expression complexe. En passant 0 comme paramètre à ce fonction, on obtient une expression indentée qui fait ressortir la structure de l'expression.</p>
    <p lang="en">This function returns a <em>string</em> version of a  <span class="jsr">jsRealB</span> expression, this can be useful for debugging complex expressions. But giving 0 as parameter of this function, the expression is indented to show the underlying structure.</p>
    <h3><code>getLanguage()</code></h3>
    <p lang="fr">Cette fonction retourne le langage courant de réalisation: <code>"fr"</code> pour le français et <code>"en"</code> pour l'anglais.</p>
    <p lang="en">This function returns the current realization language: <code>"fr"</code> for French and <code>"en"</code> for English.</p>
    <h3 id="loadEnFr"><code>loadEn(trace), loadFr(trace)</code></h3>
    <p lang="fr">Ces fonctions indiquent la langue à utiliser pour les prochaines réalisations. Il est important d'en appeler au moins une avant de débuter la réalisation d'une phrase. Le paramètre (<code>false</code> by default) est le suivant:
        <ul lang="fr">
            <li><em>trace</em> : si <code>true</code>, un message apparaîtra sur la console à la fin du chargement du lexique et de règles du langage.</li>
        </ul>
    </p>
    <p lang="en">These functions sets the current realization language; one of them should be called before starting the realization process. Its parameter, (<code>false</code> by default) is :
        <ul lang="en">
            <li><em>trace</em> : if <code>true</code>, a message is written on the console after the loading of the lexicon and language tables.</li>
        </ul>
    </p>


<!-- *** Chargement dans une page web *** -->
    <h2 lang="fr" id="pageWeb">Chargement dans une page web</h2><h2 lang="en" id="webPage">Loading in a web page</h2>
	
    <p lang="fr">Il suffit d'ajouter le script <code>jsRealB.js</code> à la liste des scripts de la page. Ceci intègre déjà deux lexiques de base: français (3 700 entrées) et anglais (5 200 entrées). Comme indiqué à la section <a href="#extensionVoc">Extension du vocabulaire</a>, il est facile d'ajouter de nouvelles entrées ou même de remplacer complètement les dictionnaires par défaut.</p>
        <p lang="en">It is only a matter of adding the script <code>jsRealB.js</code> to the scripts used by the web page. This includes two basic lexicons: English (5 200 entries) and French (3 700 entries). As shown below in the <a href="#vocExtension">Vocabulary extension section</a>, it is possible to add new entries to the lexicon or to change it completely.</p>
        <dd>
            <ul>
                <li><a href="#loadEnFr"><code>loadFr(...)</code></a> <span lang="en">should be called before starting realizing French sentences</span><span lang="fr">devrait être appelé avant de réaliser des phrases en français</span></li>
                <li><a href="#loadEnFr"><code>loadEn(...)</code></a> <span lang="en">should be called before starting realizing English sentences.</span><span lang="fr">devrait être appelé avant de réaliser des phrases en anglais</span></li>
            </ul>
            <div lang="fr">Il est possible d'appeler ces fonctions aussi souvent que nécessaire pour changer le langage de réalisation courant. Ces fonctions retournent le nouveau dictionnaire chargé.</div><div lang="en">These functions can be called as often as necessary to change the current language. Each call returns the last loaded dictionary.</div>
		</dd>
        
<p lang="fr">Idéalement, vous installerez votre propre version de <span class="jsr">jsRealB</span> à partir des sources du <a href="https://github.com/rali-udem/jsRealB">GitHub</a> et vous la référencerez depuis l'élément <code>script</code>. Mais vous pouvez aussi télécharger une version déjà <i>minifiée</i> à partir de ce <a href="https://github.com/rali-udem/jsRealB/tree/master/dist">répertoire</a>.</p>
<p lang="en">Ideally you should install your own version of <span class="jsr">jsRealB</span> from the <a href="https://github.com/rali-udem/jsRealB">GitHub</a> sources and you will refer to it using a <code>script</code> element. But you can also get <i>minified</i> versions from <a href="http://rali.iro.umontreal.ca/JSrealB/current/dist">this directory</a>.</p>
    <p lang="fr">Des exemples d'intégration dans une page web peuvent être trouvés à la section <em>Démonstrations</em> de <a href="http://rali.iro.umontreal.ca/JSrealB/current/documentation/in_action/LISEZMOI.html">cette page</a></p>
    <p lang="en">Examples of web page integration can be found at the <em>Demonstrations</em> section of <a href="http://rali.iro.umontreal.ca/JSrealB/current/">this page</a></p>


<!-- *** Module  *** -->
    <h2 lang="fr" id="moduleNode">Module <code>Node.js</code></h2><h2 lang="en" id="nodeModule"><code>Node.js</code> Module</h2>
    <p lang="fr">Les versions de <span class="jsr">jsRealB</span> décrites à la section précédente peuvent aussi être utilisées avec <code>node.js</code> en utilisant une instruction de la forme <code>jsRealB=require("...")</code></p>
    <p lang="en">The <span class="jsr">jsRealB</span> versions  can also be used with <code>node.js</code> with an instruction like <code>jsRealB=require("...")</code></p>
    <p lang="fr">Un exemple simple d'utilisation du module <code>Node.js</code> est ce <a href="../dist/jsRealB-filter.js">filtre Unix</a> qui accepte une expression <span class="jsr">jsRealB</span> sur une seule ligne et retourne sa réalisation en anglais. </p>
    <p lang="en">A simple example of the use of the <code>Node.js</code> module is this <a href="../dist/jsRealB-filter.js">Unix filter</a> which transforms a <span class="jsr">jsRealB</span> expression on a single line and returns the corresponding English realization.</p>
    <p lang="fr"><strong>Trucs pratiques</strong>:</p> 
    <p lang="en"><strong>Useful tricks</strong>:</p>
    <ul>
    <li lang="fr">l'accès aux constructeurs de syntagmes du module Node doit se faire de la façon suivante <code>jsRealB.S(...)</code> ce qui peut s'avérer laborieux. Il est donc plus pratique de définir les constructeurs dans le contexte global (même si ceci pourrait être considéré comme une mauvaise pratique en génie logiciel) en exécutant le code suivant:</li>
    <li lang="en">phrase constructors from the Node module must be called as <code>jsRealB.S(...)</code> which can be tedious. It is thus more convenient (although it could be seen as bad software engineering practice) to define these constructors in the global namespace by executing the following code:</li>
<pre>
    for (var v in jsRealB)
        eval(v+"=jsRealB."+v);
</pre>
    <li lang="fr">Un script javascript peut vérifier s'il est utilisé comme module <code>node.js</code> avec le test suivant:</li>
    <li lang="en">A javascript script can check if it used as <code>node.js</code> module with the following:</li>
    <pre>
    if (typeof module !== 'undefined' && module.exports) {
        ...
    }
    </pre>
</ul>

<!-- *** Gestion des lexiques *** -->
    <h2 lang="fr" id="extensionVoc">Gestion des lexiques</h2><h2 lang="en" id="vocExtension">Lexicon Management</h2>
<p lang="fr"> <span class="jsr">jsRealB</span> 
intègre déjà deux lexiques de base: français (3 700 entrées) et anglais (5 200 entrées) qu'il est possible de consulter et de modifier à l'aide des fonctions suivantes. Lorsque <code>lang</code> (<code>"en"</code> ou <code>"fr"</code>) est spécifié, la fonction s'applique au lexique de cette langue, sinon au lexique courant, celui du dernier appel à <code>loadEn()</code> ou <code>loadFr()</code>.
</p>
<p lang="en"> <span class="jsr">jsRealB</span> 
has already two basic lexicons: French (3 700 entries) and English (5 200 entries) that can be queried and modified with the following functions. When <code>lang</code> (<code>"en"</code> or <code>"fr"</code>) is specified, the function is applied to the lexicon of this language, otherwise it applies to the current lexicon, the one of the last call to <code>loadEn()</code> o <code>loadFr()</code>.
</p>

<h3><code>addtoLexicon(lemma[,newInfos][,lang])</code></h3>
<p lang="fr"> 
     <code>lemma</code> est l'entrée de base et <code>newInfos</code> est l'information morphologique selon le format interne à <span class="jsr">jsRealB</span>: un objet indiquant le ou les catégories possibles et pour chaque catégorie, des propriétés et la table de déclinaison ou conjugaison correspondantes.
    Par exemple, <code>addLexicon("jsRealB",{"N":{"g":"m", "pe":3, "tab": ["nI"]})</code> ajoutera le mot <code>jsRealB</code> comme nom masculin invariable au lexique courant. 
    Cette fonction peut aussi être appelée avec un seul paramètre qui est un objet dont la clé est le lemme. L'exemple précédent peut donc s'écrire: <code>addToLexicon({"tsunami":{"N":{"tab":["n1"]}}})</code>. Si le lemme et la catégorie existent déjà dans le lexique, alors l'entrée pour cette catégorie est remplacée par <code>newInfos</code>.
</p>
<p lang="fr"><a href="../data/lexiconFormat.html">Plus d'information (en anglais) sur le format des lexiques</a>   </p> 
<p lang="fr">
Pour déterminer les informations à ajouter, le plus simple est de copier les informations d'un mot du lexique qui se conjugue ou se décline de la même façon. L'<a href="../IDE/index.html">IDE de jsRealB</a> permet de consulter les informations du lexique.
</p>
<p lang="fr">Pour enlever une entrée d'un lexique, il de mettre <code>newInfos</code> à <code>null</code>.</p>
<p lang="en"> 
     <code>lemma</code> is the basic form and <code>newInfos</code> is the morphologic information according to the internal  <span class="jsr">jsRealB</span> format: an object indicating one or many possible categories. For each category, properties and declension or conjugation are given.
    For example, <code>addLexicon("jsRealB",{"N":{"g":"m", "pe":3, "tab": ["nI"]})</code> will add the <code>jsRealB</code> as a masculine invariable word. This function can also be called with a single parameter: an object whose key is the lemma. The previous example could also have been written: <code>addToLexicon({"tsunami":{"N":{"tab":["n1"]}}})</code>.  If the lemma and category are already present in the lexicon, then the category of this entry is replaced by <code>newInfos</code>.
</p>
<p lang="en"><a href="../data/lexiconFormat.html">More information about the lexicon format</a></p>
<p lang="en">
In order to find the informations to add, the simplest way is to copy the lexicon information for a similar word already in the lexicon. 
The <a href="../IDE/index.html">jsRealB IDE</a> provides access to the lexicon information.
</p>
<p lang="en">To remove an entry, set <code>newInfos</code> to <code>null</code>.</p>

<h3><code>getLemma(lemma[,lang])</code></h3>
<p lang="fr">Retourner les informations du lexique correspondant à <code>lemma</code>. </p>
<p lang="en">Return lexicon information to <code>lemma</code>. </p>

<h3><code>updateLexicon(newLexicon[,lang])</code></h3>
<p lang="fr">Fusionner les entrées de <code>newLexicon</code> avec le lexique spécifié. Ceci ajoutera les nouvelles entrées et remplacera les entrées existantes par celles du nouveau lexique. La fusion est effectuée au niveau des entrées, mais non des catégories.</p>
<p lang="en">Merge the entries of <code>newLexicon</code> with the specified lexicon. This adds the new entries and replaces the existing entries by the ones of the new lexicon. Merging is done at the entry level, not at the category level.</p>

<h3><code>getLanguage()</code></h3>
<p lang=fr>Retourne le langage de réalisation courant.</p>
<p lang=en>Returns the current realization language.</p>

<h3><code>getLexicon()</code></h3>
<p lang="fr">Retourne le lexique courant.</p>
<p lang="en">Returns the current lexicon.</p>

<!-- *** Sélection de variantes *** -->
    <h2 lang="fr" id="selectionVar">Sélection de variantes</h2><h2 lang="en" id="varSelection">Variant selection</h2>
<p lang="fr">
La fonction <code>oneOf(e<sub>1</sub>,e<sub>2</sub>,...)</code> où <code>e<sub>i</sub></code> est est une valeur, choisit un <code>e<sub>i</sub></code> au hasard. En <code>jsRealB</code>, ces éléments sont souvent des constructeurs correspondant à des structures de phrases différentes. Si <code>e<sub>1</sub></code> est une liste alors la sélection est faite dans cette liste, en ignorant les autres paramètres.
</p>
<p lang="fr">Pour éviter que tous les éléments soient évalués avant la sélection, il suffit de <em>fonctionaliser</em> l'expression en une fonction sans paramètre en la préfixant par <code>()=></code>, ce qui en fait une <em>fonction fléchée</em>. Une fois l'élément choisi, <code>oneOf</code> vérifie si la valeur est une fonction et si c'est le cas, il retourne le résultat de l'appel. Par exemple,
<code>ofOne(()=>N("amour"),()=>N("amitié"))</code> permet de choisir entre les deux noms sans évaluer les deux constructeurs. Dans ce cas, très simple, il aurait été aussi possible d'écrire <code>N(oneOf("amour","amitié"))</code>.
</p>
<p lang="en">
The function <code>oneOf(e<sub>1</sub>,e<sub>2</sub>,...)</code> where <code>e<sub>i</sub></code> is a value, selects randomly a <code>e<sub>i</sub></code>. In <code>jsRealB</code>, these elements are often constructors corresponding to different phrase structures. If <code>e<sub>1</sub></code> is a list, the selection is performed within this list, ignoring other parameters.
</p>
<p lang="en">To avoid the evaluation of all elements before the selection, it is possible to <em>functionalize</em> a expression into a function with no formal parameter by prefixing it with <code>()=></code> which makes it an <em>arrow function</em>. Once the element is selected, <code>oneOf</code> checks if the value is a function and, if it is so, it returns the value of the called function. For exemple,
<code>oneOf(()=>V("love"),()=>V("like"))</code> allows choosing between the two verbs without evaluating both constructors. In this simplistic case, this could have also been written as <code>V(oneOf("love","like"))</code>.</p>

<h2 lang="fr" id="entreeJSON">Entrée en JSON</h2><h2 lang="en" id="JSONinput">JSON input</h2>
<p lang="fr">Pour faciliter l'utilisation de <code>jsRealB</code> en sortie d'un système externe. Il est possible d'utiliser un format d'entrée JSON <a href="../data/jsRealb-jsonInput.html">décrit dans ce document (en anglais)</a>.
</p>
<p lang="en">To simplify the use of <code>jsRealB</code> as output of an external system, a JSON input format has been defined. <a href="../data/jsRealb-jsonInput.html">It is described in this document.</a>.
</p>
<!-- *** Informations complémentaires *** -->
    <h2 lang="fr" id="plusDinfo">Informations complémentaires</h2><h2 lang="en" id="moreInfo">More Information</h2>
<ul>
    <li><a href="http://rali.iro.umontreal.ca/rali/?q=fr/jsrealb-realisateur-bilingue-de-texte" lang="fr">Historique des versions et démonstrations</a><a href="http://rali.iro.umontreal.ca/rali/?q=en/jsrealb-bilingual-text-realiser" lang="en">Previous versions and demos</a></li>
    <li><a href="https://observablehq.com/@lapalme/nouvelles-experiences-avec-jsrealb" title="Nouvelles exp&#xE9;riences avec jsRealB / Guy Lapalme / Observable" lang="fr">Notebook Observable</a><a href="https://observablehq.com/@lapalme/exprimenting-with-jsrealb" title="Experimenting with jsRealB / Guy Lapalme / Observable" lang="en">Observable Notebook</a></li>
    <li><a href="../IDE/README.html">Interactive Development Environment</a></li>
    <li><a href="http://rali.iro.umontreal.ca/JSrealB/current/Tutorial/tutorial.html" title="jsRealB tutorial" lang="fr">Tutoriel (en anglais)</a><a href="http://rali.iro.umontreal.ca/JSrealB/current/Tutorial/tutorial.html" title="jsRealB tutorial" lang="en">Tutorial</a></li>
    <li><a href="https://github.com/rali-udem/JSrealB" lang="fr">Dépot GitHub</a><a href="https://github.com/rali-udem/JSrealB" lang="en">GitHub repository</a></li>
    <li><a href="../data/lexiconFormat.html" lang="fr">Format des entrées de lexiques (en anglais)</a><a href="../data/lexiconFormat.html" lang="en">Format of the lexicon entries</a></li>
    <li>Publications:
        <ul>
            <li><a href="http://rali.iro.umontreal.ca/rali/sites/default/files/publis/JSrealB-ENGL2015.pdf">Demo paper at ENLG-2015</a></li>
            <li>Daoust, N., and G. Lapalme, <em>JSreal: A Text Realizer for Web Programming</em>, Language Production, Cognition, and the Lexicon - a Festschrift in honor of Michael Zock, Text, Speech and Language Technology, Vol 48: Springer, pp. 363-378, 2014. [<a href="http://rali.iro.umontreal.ca/rali/sites/default/files/publis/JSreal.pdf">PDF</a>]</li>
        </ul>
    </li>
</ul>

<footer>Contact: <a href="lapalme@iro.umontreal.ca">Guy Lapalme</a> <a href="http://rali.iro.umontreal.ca">RALI</a>, Université de Montréal, CANADA. 2018.</footer>
</body>
</html>
