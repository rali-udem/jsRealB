// Program argument parsing
// arguments : lang file.conllu
const argv=process.argv.slice(2);
if (argv.length==0 || argv[0].startsWith("-h")){
    console.log("usage: node UDregenerator-node.js lang [-sud] inputFile\n"+
                "   lang: en|fr\n"+
                "   -sud : use SUD annotation scheme instead of classical UD\n"+
                "   inputFile: path of CONLLU file\n");
    process.exit(0)
}
const language=argv[0];
if (language!="en" && language!="fr"){
    console.log('only "en" or "fr" implemented');
    process.exit(1)
}
if (argv.length<2){
    console.log("missing input file")
    process.exit(1);
}
let isSUD = false
if (argv[1]=="-sud"){
    isSUD=true
    argv.splice(1,1)
}
if (argv.length<2){
    console.log("missing input file")
    process.exit(1);
}
const fileName=argv[1];

function regenerate (fileContent){
    // update dictionary
    enfr.addNewWords()
    setQuoteOOV(true)

    const fmt="# %s = %s";
    let nbDiffs=0, nbWarnings=0, nbNonProjective=0;
    // UDregenerator execution
    const uds=parseUDs(fileContent,fileName);
    uds.forEach(function (ud,i){
        console.log("%d: %s",i,ud.sent_id);
        // use the same variable names as for UDregenerator.js
        resetSavedWarnings();
        let udCloned=ud.similiClone(language);
        // remove ending full stop, it will be regenerated by jsRealB
        if (udCloned.right.length>0){
            let lastIdx=udCloned.right.length-1;
            if (udCloned.right[lastIdx].deprel=="punct" && udCloned.right[lastIdx].lemma=="."){
                udCloned.right.splice(lastIdx,1)
            }
        }
        let jsr=udCloned.toDependent(isSUD)
        // if root is a coord, add a dummy root, so that realization will be done correctly
        if (jsr.isA('coord'))jsr=root(Q(""),jsr)
        // const jsRealBexpr=jsr;
        const jsRealBsent=jsr.clone().toString();
        const warnings=getSavedWarnings();
        const diffs=computeDiffs(ud.text,jsRealBsent);
        if (!ud.isProjective){
            nbNonProjective++;
            console.log("## non projective");
        }
        let nb=diffs[3];
        if (nb>0){
            nbDiffs++;
            const [d1,d2]=showDiffs(diffs,addColoredStr);
            console.log("%d %s%s",nb,language=="en"?"difference":"différence",nb==1?"":"s");
            console.log(fmt, "text",d1);
            console.log(fmt, "TEXT",d2);
        } else {
            console.log(fmt, "text",ud.text);
            console.log(fmt, "TEXT",jsRealBsent);
        }
        nb=warnings.length;
        if (nb>0){
            nbWarnings++;
            console.log("%d %s%s: %s",nb,language=="en"?"warnings":"avertissement",nb>1?"s":"",ud.sent_id);
            console.log(warnings.join("\n"));
        }
        console.log("---");
    });

    // output global statistics    
    console.log(language=="en"?"%d UD processed":"%d UD traitées",uds.length)
    console.log(language=="en"?"%d UD non projective found":"%d UD non projectives",nbNonProjective);
    console.log(language=="en"?"%d UD different found":"%d UD différentes",nbDiffs);
    console.log(language=="en"?"%d UD with warnings found":"%d UD avec avertissements",nbWarnings);
}

///   start of processing
import { readFileSync } from 'fs';
const fileContent = readFileSync(fileName,{encoding:'utf8', flag:'r'});
//////// 
//  load JSrealB
let {default:jsRealB} =await import('../../dist/jsRealB.js');
Object.assign(globalThis,jsRealB);
import { computeDiffs, showDiffs, addColoredStr } from "./levenshtein.js";
import { parseUDs } from "./UDregenerator.js";

let enfr = await import(`./UDregenerator-${language}.js`);
regenerate(fileContent,fileName);


